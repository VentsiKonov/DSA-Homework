Моят тестов клас генерира четири типа данни:
сортиран масив
обърнат масив
наполовина сортиран, наполовина обърнат масив
масив със случайни данни

Направих и допълнителна структура с размер 200 байта, с която да тествам алгоритмите.

Тестовият клас разчита на наличието на operator=(int) за всеки подаден му тип.

Алгоритмите за сортиране разчитат на наличието на оператори за сравнение.

Merge, Heap и Quicksort се справят почти за еднакво време, като при по-голям обем от данни забелязах, че quicksort се справя по-бавно с полу-сортирания масив,
а heapsort се справя много добре с обърнатия наобратно.
Shellsort бързо регистрира сортирания масив и се справя добре с подредените по някакъв начин такива, но се забавя значително при разбъркани данни.
Производителността на mergesort е консистентна при всички типове и подредба на данните.
Insertion sort се бави изключително много спрямо всички останали решения, затова и в два от файловете с изхода от тестването не е включен в данните.

